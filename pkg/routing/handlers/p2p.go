package handlers

import (
	"encoding/json"
	"net/http"
	"strconv"

	"github.com/gladiusio/gladius-controld/pkg/p2p/message"
	"github.com/gladiusio/gladius-controld/pkg/p2p/signature"
)

type messageBody struct {
	Message    string `json:"message"`
	Passphrase string `json:"passphrase"`
}

type signatureBody struct {
	Message   string `json:"message"`
	Hash      string `json:"hash"`
	Signature string `json:"signature"`
	Address   string `json:"address"`
}

func stateBodyDecoder(w http.ResponseWriter, r *http.Request) (*messageBody, error) {
	decoder := json.NewDecoder(r.Body)
	var body messageBody
	err := decoder.Decode(&body)

	if err != nil {
		return nil, err
	}

	defer r.Body.Close()

	return &body, nil
}

func signatureBodyDecoder(w http.ResponseWriter, r *http.Request) (*signatureBody, error) {
	decoder := json.NewDecoder(r.Body)
	var body signatureBody
	err := decoder.Decode(&body)

	if err != nil {
		return nil, err
	}

	defer r.Body.Close()

	return &body, nil
}

func PeerToPeerStateUpdateHandler(w http.ResponseWriter, r *http.Request) {
	body, err := stateBodyDecoder(w, r)
	if err != nil {
		ErrorHandler(w, r, "Could not find `passphrase` or could not find `message` in request", err, http.StatusInternalServerError)
		return
	}
	message := message.New(body.Message)

	signed, err := signature.CreateSignedMessage(message, body.Passphrase)
	if err != nil {
		ErrorHandler(w, r, "Could not find sign message. Passphrase likely incorrect.", err, http.StatusInternalServerError)
		return
	}
	ResponseHandler(w, r, "null", signed)
}

func VerifySignedMessageHandler(w http.ResponseWriter, r *http.Request) {
	body, err := signatureBodyDecoder(w, r)
	if err != nil {
		ErrorHandler(w, r, "Missing one or more of: `message`, `hash`, `signature`, `address`", err, http.StatusInternalServerError)
		return
	}

	parsed, err := signature.ParseSignedMessage(body.Message, body.Hash, body.Signature, body.Address)
	if err != nil {
		ErrorHandler(w, r, "Couldn't parse body", err, http.StatusInternalServerError)
		return
	}
	verified, err := signature.VerifySignedMessage(parsed)
	if err != nil {
		ErrorHandler(w, r, "Error veryfing signature", err, http.StatusInternalServerError)
		return
	}

	ResponseHandler(w, r, "null", strconv.FormatBool(verified))
}

/*******************************************************************************
All methods below use the account generated by the gladius account manager
*******************************************************************************/

// DiscoveryHandler takes in a the given peer and asks it for the current
// network state. This allows the node to get information on other nodes,
// where to find content, etc.
func DiscoveryHandler(w http.ResponseWriter, r *http.Request) {

}

// StartUpHandler is a wrapper for updating the network state at startup.
// It handles hearbeat setup, changes to public IP address, current content on
// disk, etc.
func StartUpHandler(w http.ResponseWriter, r *http.Request) {

}

// UpdateStateHandler updates state with signed update and pushes state to a set
// of random peers. They then propigate it to their peers until the network has
// a consistent state
func UpdateStateHandler(w http.ResponseWriter, r *http.Request) {

}

// GetFullStateHandler gets the current state the node has access to.
func GetFullStateHandler(w http.ResponseWriter, r *http.Request) {

}

// GetContentLocationHandler will compare the content list provided with the
// current state and return a list of links to download content from a peer that
// has the it
func GetContentLocationHandler(w http.ResponseWriter, r *http.Request) {

}
