package handlers

import (
	"encoding/json"
	"io/ioutil"
	"net/http"
	"strconv"

	"github.com/buger/jsonparser"

	"github.com/gladiusio/gladius-controld/pkg/p2p/message"
	"github.com/gladiusio/gladius-controld/pkg/p2p/peer"
	"github.com/gladiusio/gladius-controld/pkg/p2p/signature"
)

// Helper to create signed message from body
func getSignedMessageFromBody(w http.ResponseWriter, r *http.Request) *signature.SignedMessage {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		ErrorHandler(w, r, "Error decoding body", err, http.StatusBadRequest)
		return nil
	}

	messageBytes, _, _, err := jsonparser.Get(body, "message")
	if err != nil {
		ErrorHandler(w, r, "Could not find `message` in body", err, http.StatusBadRequest)
		return nil
	}

	hash, err := jsonparser.GetString(body, "hash")
	if err != nil {
		ErrorHandler(w, r, "Could not find `hash` in body", err, http.StatusBadRequest)
		return nil
	}

	signatureString, err := jsonparser.GetString(body, "signature")
	if err != nil {
		ErrorHandler(w, r, "Could not find `signature` in body", err, http.StatusBadRequest)
		return nil
	}

	address, err := jsonparser.GetString(body, "address")
	if err != nil {
		ErrorHandler(w, r, "Could not find `address` in body", err, http.StatusBadRequest)
		return nil
	}

	parsed, err := signature.ParseSignedMessage(string(messageBytes), hash, signatureString, address)
	if err != nil {
		ErrorHandler(w, r, "Couldn't parse body", err, http.StatusBadRequest)
		return nil
	}

	return parsed
}

// Helper to get fields from the json body and verify the signature
func verifyBody(w http.ResponseWriter, r *http.Request) bool {
	parsed := getSignedMessageFromBody(w, r)
	verified, err := signature.VerifySignedMessage(parsed)
	if err != nil {
		ErrorHandler(w, r, "Error veryfing signature", err, http.StatusBadRequest)
		return false
	}

	return verified
}

func getContentListFromBody(w http.ResponseWriter, r *http.Request) []string {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		ErrorHandler(w, r, "Error decoding body", err, http.StatusBadRequest)
		return nil
	}
	s := make([]string, 5)
	// Get all content file names passed in
	jsonparser.ArrayEach(body, func(value []byte, dataType jsonparser.ValueType, offset int, err error) {
		s = append(s, string(value))
	}, "content")

	return s
}

// VerifySignedMessageHandler verifies the incoming message with takes the form
// of:
// {"message": "b64string", "hash": "b64string", "signature": "b64string", "address": ""}
func VerifySignedMessageHandler(w http.ResponseWriter, r *http.Request) {
	ResponseHandler(w, r, "null", strconv.FormatBool(verifyBody(w, r)))
}

/*******************************************************************************
All methods below use the account generated by the gladius account manager
*******************************************************************************/

// CreateSignedMessageHandler takes the incoming message and returns a signed
// version that includes the timestamp.
func CreateSignedMessageHandler(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		ErrorHandler(w, r, "Error decoding body", err, http.StatusBadRequest)
		return
	}
	messageBytes, _, _, err := jsonparser.Get(body, "message")
	if err != nil {
		ErrorHandler(w, r, "Could not find `message` in body", err, http.StatusBadRequest)
		return
	}

	passphrase, err := jsonparser.GetString(body, "passphrase")
	if err != nil {
		ErrorHandler(w, r, "Could not find `passphrase` in body", err, http.StatusBadRequest)
		return
	}

	signed, err := signature.CreateSignedMessage(message.New(messageBytes), string(passphrase))
	if err != nil {
		ErrorHandler(w, r, "Could not create sign message. Passphrase likely incorrect.", err, http.StatusBadRequest)
		return
	}

	ResponseHandler(w, r, "null", signed)
}

// PushStateMessageHandler updates state with signed update and pushes state to
// a set of random peers. They then propigate it to their peers until the
// network has a consistent state
func PushStateMessageHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		if verifyBody(w, r) {
			message := getSignedMessageFromBody(w, r)
			p.UpdateAndPushState(message)
			ResponseHandler(w, r, "null", "updated")
		} else {
			ErrorHandler(w, r, "Cannot verifiy signature", nil, http.StatusBadRequest)
		}
	}
}

// GetFullStateHandler gets the current state the node has access to.
func GetFullStateHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		json, err := p.GetState().GetJSON()
		if err != nil {
			ErrorHandler(w, r, "Error creating JSON state", nil, http.StatusInternalServerError)
		}
		ResponseHandler(w, r, "null", string(json))
	}
}

// GetContentHandler will compare the content list provided with the
// current state and return a list of links to download content from a peer that
// has the same set as the network state. It also includes a hash of that file
// so the node can verify it before serving.
func GetContentHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		list := getContentListFromBody(w, r)
		needed := p.CompareContent(list)
		neededJSON, err := json.Marshal(needed)
		if err != nil {
			ErrorHandler(w, r, "Error creating difference list", nil, http.StatusInternalServerError)
		}
		ResponseHandler(w, r, "null", string(neededJSON))
	}
}
